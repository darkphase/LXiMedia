--- upnp/inc/upnp.h	2014-06-15 11:42:00.520991000 +0200
+++ upnp/inc/upnp.h	2014-06-15 11:42:31.768992150 +0200
@@ -433,6 +433,16 @@
  */
 typedef int  UpnpDevice_Handle;
 
+struct Request_Info
+{
+    /** The IP address and port used to perform this request. */
+    char host[NAME_SIZE];
+    /** The user agent used to perform this request. */
+    char userAgent[NAME_SIZE];
+    /** The address the request came from. */
+    char sourceAddress[INET6_ADDRSTRLEN];
+};
+
 /*!
  * \brief The reason code for an event callback.
  *
@@ -613,6 +623,9 @@
   /** The error string in case of error. */
   char ErrStr[LINE_SIZE];
 
+  /** The Request_Info structure used to perform this request. */
+  struct Request_Info RequestInfo;
+
  /** The Action Name. */
   char ActionName[NAME_SIZE];
 
@@ -788,6 +801,9 @@
 
 struct Upnp_Subscription_Request
 {
+  /** The IP address and port used to perform this request. */
+  char Host[NAME_SIZE];
+
   /** The identifier for the service being subscribed to. */
   char *ServiceId; 
 
@@ -876,6 +892,18 @@
  */
 
 /*!
+ * \brief Returns the local alvailable IPv4 ip addresses.
+ *
+ * This function can be called before UpnpInit to determine the addresses to
+ * pass to UpnpInit.
+ *
+ * \return
+ * 	\li On success: A NULL terminated list of the  IPv4 addresses.
+ * 	\li On error: \c NULL is returned.
+ */
+EXPORT_SPEC char **UpnpGetAvailableIpAddresses(void);
+
+/*!
  * \brief Initializes the Linux SDK for UPnP Devices (IPv4 only).
  *
  * \deprecated Kept for backwards compatibility. Use UpnpInit2 for new
@@ -891,7 +919,7 @@
  * process, multiple processes using the SDK must specify
  * different port numbers.
  *
- * If unspecified, the SDK will use the first IPv4-capable adapter's IP address
+ * If unspecified, the SDK will use all IPv4-capable adapter's IP address
  * and an arbitrary port.
  *
  * This call is synchronous.
@@ -960,6 +988,45 @@
 #endif
 
 /*!
+ * \brief Initializes the Linux SDK for UPnP Devices (IPv4 only).
+ *
+ * This function must be called before any other API function can be called.
+ * It should be called only once. Subsequent calls to this API return a
+ * \c UPNP_E_INIT error code.
+ *
+ * Optionally, the application can specify set of host IPv4 addresses (in the
+ * case of a multi-homed configuration) and a port number to use for
+ * all UPnP operations.  Since a port number can be used only by one
+ * process, multiple processes using the SDK must specify
+ * different port numbers.
+ *
+ * If unspecified, the SDK will use all IPv4-capable adapter's IP address
+ * and an arbitrary port.
+ *
+ * This call is synchronous.
+ *
+ * \return An integer representing one of the following:
+ *     \li \c UPNP_E_SUCCESS: The operation completed successfully.
+ *     \li \c UPNP_E_OUTOF_MEMORY: Insufficient resources exist
+ *             to initialize the SDK.
+ *     \li \c UPNP_E_INIT: The SDK is already initialized.
+ *     \li \c UPNP_E_INIT_FAILED: The SDK initialization
+ *             failed for an unknown reason.
+ *     \li \c UPNP_E_SOCKET_BIND: An error occurred binding a socket.
+ *     \li \c UPNP_E_LISTEN: An error occurred listening to a socket.
+ *     \li \c UPNP_E_OUTOF_SOCKET: An error ocurred creating a socket.
+ *     \li \c UPNP_E_INTERNAL_ERROR: An internal error ocurred.
+ */
+EXPORT_SPEC int UpnpInit3(
+    /*! A NULL terminated list of host local IPv4 addresses to use, in string
+     * format, for example "192.168.0.1", or \c NULL to use all IPv4 adapter's
+     * IP addresses. */
+    const char **HostIPs,
+    /*! Local Port to listen for incoming connections
+     * \c NULL will pick an arbitrary free port. */
+    unsigned short DestPort);
+
+/*!
  * \brief Terminates the Linux SDK for UPnP Devices.
  *
  * \li Checks for pending jobs and threads
@@ -1021,6 +1088,19 @@
 EXPORT_SPEC char *UpnpGetServerIpAddress(void);
 
 /*!
+ * \brief Returns the local IPv4 listening ip addresses.
+ *
+ * If \c NULL is used as the IPv4 address in \b UpnpInit, then this function can
+ * be used to retrieve the actual interface addresses on which device is running.
+ *
+ * \return
+ * 	\li On success: A NULL terminated list of the  IPv4 addresses on which an
+ *      internal server is listening for UPnP related requests.
+ * 	\li On error: \c NULL is returned if \b UpnpInit has not succeeded.
+ */
+EXPORT_SPEC char **UpnpGetServerIpAddresses(void);
+
+/*!
  * \brief Returns the local IPv6 listening ip address.
  *
  * If \c NULL is used as the IPv6 address in \b UpnpInit, then this function can
@@ -2670,9 +2750,11 @@
  * \brief Get-info callback function prototype.
  */
 typedef int (*VDCallback_GetInfo)(
-		/*! [in] The name of the file to query. */
+        /*! [in] The IP address and port used to perform this request. */
+        struct Request_Info *request,
+        /*! [in] The name of the file to query. */
 		const char *filename,
-		/*! [out] Pointer to a structure to store the information on the file. */
+        /*! [out] Pointer to a structure to store the information on the file. */
 #if UPNP_VERSION < 10800
 		struct File_Info *info
 #else
@@ -2694,9 +2776,11 @@
  * \brief Open callback function prototype.
  */
 typedef UpnpWebFileHandle (*VDCallback_Open)(
-		/*! [in] The name of the file to open. */ 
+        /*! [in] The IP address and port used to perform this request. */
+        struct Request_Info *request,
+        /*! [in] The name of the file to open. */
 		const char *filename,
-		/*! [in] The mode in which to open the file.
+        /*! [in] The mode in which to open the file.
 		 * Valid values are \c UPNP_READ or \c UPNP_WRITE. */
 		enum UpnpOpenFileMode Mode);
 
--- upnp/src/api/upnpapi.c	2013-11-15 17:01:35.000000000 +0100
+++ upnp/src/api/upnpapi.c	2014-06-19 21:20:52.068142305 +0200
@@ -130,7 +130,12 @@
 char gIF_NAME[LINE_SIZE] = { '\0' };
 
 /*! Static buffer to contain interface IPv4 address. (extern'ed in upnp.h) */
-char gIF_IPV4[INET_ADDRSTRLEN] = { '\0' };
+char * gIFIP_IPV4[MAX_INTERFACES + 1] = { 0 };
+char gIFIP_IPV4_MEMORY[INET_ADDRSTRLEN * MAX_INTERFACES];
+
+/*! Static buffer to contain interface IPv4 netmasks. (extern'ed in upnp.h) */
+char * gIFNM_IPV4[MAX_INTERFACES + 1] = { 0 };
+char gIFNM_IPV4_MEMORY[INET_ADDRSTRLEN * MAX_INTERFACES];
 
 /*! Static buffer to contain interface IPv6 address. (extern'ed in upnp.h) */
 char gIF_IPV6[INET6_ADDRSTRLEN] = { '\0' };
@@ -180,6 +185,12 @@
 Upnp_SID gUpnpSdkNLSuuid;
 #endif /* UPNP_HAVE_OPTSSDP */
 
+#ifdef WIN32
+/*! Global variable to denote the state of Winsock == 0 if uninitialized,
+ * == 1 if initialized. */
+int WinsockInitialized = 0;
+#endif
+
 
 /*!
  * \brief (Windows Only) Initializes the Windows Winsock library.
@@ -194,28 +205,31 @@
 	WSADATA wsaData;
 	int err;
 
-	wVersionRequested = MAKEWORD(2, 2);
-	err = WSAStartup(wVersionRequested, &wsaData);
-	if (err != 0) {
-		/* Tell the user that we could not find a usable */
-		/* WinSock DLL.                                  */
-		retVal = UPNP_E_INIT_FAILED;
-		goto exit_function;
-	}
-	/* Confirm that the WinSock DLL supports 2.2.
-	 * Note that if the DLL supports versions greater
-	 * than 2.2 in addition to 2.2, it will still return
-	 * 2.2 in wVersion since that is the version we
-	 * requested. */
-	if (LOBYTE(wsaData.wVersion) != 2 ||
-	    HIBYTE(wsaData.wVersion) != 2) {
-		/* Tell the user that we could not find a usable
-		 * WinSock DLL. */
-		WSACleanup();
-		retVal = UPNP_E_INIT_FAILED; 
-		goto exit_function;
-	}
-	/* The WinSock DLL is acceptable. Proceed. */
+    if (WinsockInitialized == 0) {
+        wVersionRequested = MAKEWORD(2, 2);
+        err = WSAStartup(wVersionRequested, &wsaData);
+        if (err != 0) {
+            /* Tell the user that we could not find a usable */
+            /* WinSock DLL.                                  */
+            retVal = UPNP_E_INIT_FAILED;
+            goto exit_function;
+        }
+        /* Confirm that the WinSock DLL supports 2.2.
+         * Note that if the DLL supports versions greater
+         * than 2.2 in addition to 2.2, it will still return
+         * 2.2 in wVersion since that is the version we
+         * requested. */
+        if (LOBYTE(wsaData.wVersion) != 2 ||
+            HIBYTE(wsaData.wVersion) != 2) {
+            /* Tell the user that we could not find a usable
+             * WinSock DLL. */
+            WSACleanup();
+            retVal = UPNP_E_INIT_FAILED;
+            goto exit_function;
+        }
+        /* The WinSock DLL is acceptable. Proceed. */
+        WinsockInitialized = 1;
+    }
 exit_function:
 #else
 #endif
@@ -428,10 +442,36 @@
 	return UPNP_E_SUCCESS;
 }
 
+/*! Static buffers to contain interface IPv4 address for UpnpGetAvailableIpAddresses. */
+char * gAVIFIP_IPV4[MAX_INTERFACES + 1] = { 0 };
+char gAVIFIP_IPV4_MEMORY[INET_ADDRSTRLEN * MAX_INTERFACES];
+
+char **UpnpGetAvailableIpAddresses(void)
+{
+    char dummy[INET_ADDRSTRLEN * MAX_INTERFACES];
+    int i;
+
+    memset(gAVIFIP_IPV4, 0, sizeof(gAVIFIP_IPV4));
+    memset(gAVIFIP_IPV4_MEMORY, 0, sizeof(gAVIFIP_IPV4_MEMORY));
+    memset(dummy, 0, sizeof(dummy));
+
+    WinsockInit();
+
+    i = getlocalhostnames( gAVIFIP_IPV4_MEMORY, dummy, sizeof(gAVIFIP_IPV4_MEMORY) );
+    if (i < UPNP_E_SUCCESS ) {
+        return NULL;
+    }
+    for (; i > 0; i--) {
+        gAVIFIP_IPV4[i - 1] = gAVIFIP_IPV4_MEMORY + ((i - 1) * INET_ADDRSTRLEN);
+    }
+
+    return gAVIFIP_IPV4;
+}
 
 int UpnpInit(const char *HostIP, unsigned short DestPort)
 {
 	int retVal = UPNP_E_SUCCESS;
+    int i;
 
 	/* Initializes the ithread library */
 	ithread_initialize_library();
@@ -454,15 +494,25 @@
 		"UpnpInit with HostIP=%s, DestPort=%d.\n", 
 		HostIP ? HostIP : "", (int)DestPort);
 
-	/* Verify HostIP, if provided, or find it ourselves. */
-	memset(gIF_IPV4, 0, sizeof(gIF_IPV4));
-	if (HostIP != NULL) {
-		strncpy(gIF_IPV4, HostIP, sizeof(gIF_IPV4) - 1);
+    memset(gIFIP_IPV4, 0, sizeof(gIFIP_IPV4));
+    memset(gIFIP_IPV4_MEMORY, 0, sizeof(gIFIP_IPV4_MEMORY));
+    memset(gIFNM_IPV4, 0, sizeof(gIFNM_IPV4));
+    memset(gIFNM_IPV4_MEMORY, 0, sizeof(gIFNM_IPV4_MEMORY));
+
+    /* Verify HostIP, if provided, or find it ourselves. */
+    if (HostIP != NULL) {
+        gIFIP_IPV4[0] = gIFIP_IPV4_MEMORY;
+        strncpy(gIFIP_IPV4[0], HostIP, INET_ADDRSTRLEN - 1);
 	} else {
-		if( getlocalhostname( gIF_IPV4, sizeof(gIF_IPV4) - 1 ) != UPNP_E_SUCCESS ) {
-			retVal = UPNP_E_INIT_FAILED;
-			goto exit_function;
-		}
+        i = getlocalhostnames( gIFIP_IPV4_MEMORY, gIFNM_IPV4_MEMORY, sizeof(gIFIP_IPV4_MEMORY) );
+        if (i < UPNP_E_SUCCESS ) {
+            retVal = UPNP_E_INIT_FAILED;
+            goto exit_function;
+        }
+        for (; i > 0; i--) {
+            gIFIP_IPV4[i - 1] = gIFIP_IPV4_MEMORY + ((i - 1) * INET_ADDRSTRLEN);
+            gIFNM_IPV4[i - 1] = gIFNM_IPV4_MEMORY + ((i - 1) * INET_ADDRSTRLEN);
+        }
 	}
 
 	/* Set the UpnpSdkInit flag to 1 to indicate we're successfully initialized. */
@@ -475,9 +525,11 @@
 		goto exit_function;
 	}
 
-	UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
-		"Host Ip: %s Host Port: %d\n", gIF_IPV4,
-		(int)LOCAL_PORT_V4);
+    for (i = 0; gIFIP_IPV4[i] && (i < MAX_INTERFACES); i++) {
+        UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
+                   "Host Ip: %s Host Port: %d\n", gIFIP_IPV4[i],
+            (int)LOCAL_PORT_V4);
+    }
 
 exit_function:
 	ithread_mutex_unlock(&gSDKInitMutex);
@@ -534,6 +586,104 @@
 }
 #endif
 
+int UpnpInit3(const char **HostIPs, unsigned short DestPort)
+{
+    int retVal = UPNP_E_SUCCESS;
+    int i, found;
+    const char **j;
+
+    /* Initializes the ithread library */
+    ithread_initialize_library();
+
+    ithread_mutex_lock(&gSDKInitMutex);
+
+    /* Check if we're already initialized. */
+    if (UpnpSdkInit == 1) {
+        retVal = UPNP_E_INIT;
+        goto exit_function;
+    }
+
+    /* Perform initialization preamble. */
+    retVal = UpnpInitPreamble();
+    if (retVal != UPNP_E_SUCCESS) {
+        goto exit_function;
+    }
+
+    UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
+        "UpnpInit3 with HostIP=%s, DestPort=%d.\n",
+        HostIPs ? "not NULL" : "NULL", (int)DestPort);
+
+    memset(gIFIP_IPV4, 0, sizeof(gIFIP_IPV4));
+    memset(gIFIP_IPV4_MEMORY, 0, sizeof(gIFIP_IPV4_MEMORY));
+    memset(gIFNM_IPV4, 0, sizeof(gIFNM_IPV4));
+    memset(gIFNM_IPV4_MEMORY, 0, sizeof(gIFNM_IPV4_MEMORY));
+
+    i = getlocalhostnames( gIFIP_IPV4_MEMORY, gIFNM_IPV4_MEMORY, sizeof(gIFIP_IPV4_MEMORY) );
+    if (i < UPNP_E_SUCCESS ) {
+        retVal = UPNP_E_INIT_FAILED;
+        goto exit_function;
+    }
+    for (; i > 0; i--) {
+        gIFIP_IPV4[i - 1] = gIFIP_IPV4_MEMORY + ((i - 1) * INET_ADDRSTRLEN);
+        gIFNM_IPV4[i - 1] = gIFNM_IPV4_MEMORY + ((i - 1) * INET_ADDRSTRLEN);
+    }
+
+    if (HostIPs) {
+        /* Clear items from the list that were not selected. */
+        for (i = 0; gIFIP_IPV4[i] && (i < MAX_INTERFACES); i++) {
+            found = 0;
+            for (j = HostIPs; *j; j++) {
+                if (strcmp(*j, gIFIP_IPV4[i]) == 0) {
+                    found = 1;
+                    break;
+                }
+            }
+            if (found == 0) {
+                gIFIP_IPV4[i] = NULL;
+                gIFNM_IPV4[i] = NULL;
+            }
+        }
+
+        found = 0;
+        for (i = 0; i < MAX_INTERFACES; i++) {
+            if (gIFIP_IPV4[i]) {
+                gIFIP_IPV4[found] = gIFIP_IPV4[i];
+                gIFNM_IPV4[found] = gIFNM_IPV4[i];
+                found++;
+            }
+        }
+        if (found == 0) {
+            retVal = UPNP_E_INIT_FAILED;
+            goto exit_function;
+        }
+        for (; found < MAX_INTERFACES; found++) {
+            gIFIP_IPV4[i] = NULL;
+            gIFNM_IPV4[i] = NULL;
+        }
+    }
+
+    /* Set the UpnpSdkInit flag to 1 to indicate we're successfully initialized. */
+    UpnpSdkInit = 1;
+
+    /* Finish initializing the SDK. */
+    retVal = UpnpInitStartServers(DestPort);
+    if (retVal != UPNP_E_SUCCESS) {
+        UpnpSdkInit = 0;
+        goto exit_function;
+    }
+
+    for (i = 0; gIFIP_IPV4[i] && (i < MAX_INTERFACES); i++) {
+        UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
+                   "Host Ip: %s Host Port: %d\n", gIFIP_IPV4[i],
+            (int)LOCAL_PORT_V4);
+    }
+
+exit_function:
+    ithread_mutex_unlock(&gSDKInitMutex);
+
+    return retVal;
+}
+
 #ifdef DEBUG
 /*!
  * \brief Prints thread pool statistics.
@@ -596,13 +746,11 @@
 
 int UpnpFinish(void)
 {
-#ifdef INCLUDE_DEVICE_APIS
-	UpnpDevice_Handle device_handle;
-#endif
 #ifdef INCLUDE_CLIENT_APIS
 	UpnpClient_Handle client_handle;
 #endif
 	struct Handle_Info *temp;
+    int i;
 
 	if (UpnpSdkInit != 1)
 		return UPNP_E_FINISH;
@@ -618,20 +766,11 @@
 	PrintThreadPoolStats(&gMiniServerThreadPool, __FILE__, __LINE__,
 		"MiniServer Thread Pool");
 #ifdef INCLUDE_DEVICE_APIS
-	switch (GetDeviceHandleInfo(AF_INET, &device_handle, &temp)) {
-	case HND_DEVICE:
-		UpnpUnRegisterRootDevice(device_handle);
-		break;
-	default:
-		break;
-	}
-	switch (GetDeviceHandleInfo(AF_INET6, &device_handle, &temp)) {
-	case HND_DEVICE:
-		UpnpUnRegisterRootDevice(device_handle);
-		break;
-	default:
-		break;
-	}
+    for (i = 1; i < NUM_HANDLE; i++) {
+        if (GetHandleInfo(i, &temp) == HND_DEVICE) {
+            UpnpUnRegisterRootDevice(i);
+        }
+    }
 #endif
 #ifdef INCLUDE_CLIENT_APIS
 	switch (GetClientHandleInfo(&client_handle, &temp)) {
@@ -698,7 +837,15 @@
 	if (UpnpSdkInit != 1)
 		return NULL;
 
-	return gIF_IPV4;
+    return gIFIP_IPV4[0];
+}
+
+char **UpnpGetServerIpAddresses(void)
+{
+    if (UpnpSdkInit != 1)
+        return NULL;
+
+    return gIFIP_IPV4;
 }
 
 char *UpnpGetServerIp6Address(void)
@@ -799,11 +946,6 @@
 		goto exit_function;
 	}
 
-	if (UpnpSdkDeviceRegisteredV4 == 1) {
-		retVal = UPNP_E_ALREADY_REGISTERED;
-		goto exit_function;
-	}
-
 	*Hnd = GetFreeHandle();
 	if (*Hnd == UPNP_E_OUTOF_HANDLE) {
 		retVal = UPNP_E_OUTOF_MEMORY;
@@ -901,7 +1043,7 @@
 	}
 #endif /* EXCLUDE_GENA */
 
-	UpnpSdkDeviceRegisteredV4 = 1;
+    UpnpSdkDeviceRegisteredV4++;
 
 	retVal = UPNP_E_SUCCESS;
 
@@ -965,11 +1107,6 @@
 		goto exit_function;
 	}
 
-	if (UpnpSdkDeviceRegisteredV4 == 1) {
-		retVal = UPNP_E_ALREADY_REGISTERED;
-		goto exit_function;
-	}
-
 	*Hnd = GetFreeHandle();
 	if (*Hnd == UPNP_E_OUTOF_HANDLE) {
 		retVal = UPNP_E_OUTOF_MEMORY;
@@ -1064,7 +1201,7 @@
 	}
 #endif /* EXCLUDE_GENA */
 
-	UpnpSdkDeviceRegisteredV4 = 1;
+    UpnpSdkDeviceRegisteredV4++;
 
 	retVal = UPNP_E_SUCCESS;
 
@@ -1127,11 +1264,6 @@
 		retVal = UPNP_E_INVALID_PARAM;
 		goto exit_function;
 	}
-	/* Test for already regsitered IPV4. */
-	if (AddressFamily == AF_INET && UpnpSdkDeviceRegisteredV4 == 1) {
-		retVal = UPNP_E_ALREADY_REGISTERED;
-		goto exit_function;
-	}
 	/* Test for already registered IPV6. IPV6 devices might register on multiple
 	 * IPv6 addresses (link local and GUA or ULA), so we must to check the
 	 * description URL in the HandleTable. */
@@ -1239,7 +1371,7 @@
 
 	switch (AddressFamily) {
 	case AF_INET:
-		UpnpSdkDeviceRegisteredV4 = 1;
+        UpnpSdkDeviceRegisteredV4++;
 		break;
 	default:
 		UpnpSdkDeviceregisteredV6 = 1;
@@ -1321,7 +1453,7 @@
 #endif /* INTERNAL_WEB_SERVER */
 	switch (HInfo->DeviceAf) {
 	case AF_INET:
-		UpnpSdkDeviceRegisteredV4 = 0;
+        UpnpSdkDeviceRegisteredV4--;
 		break;
 	case AF_INET6:
 		UpnpSdkDeviceregisteredV6 = 0;
@@ -1476,6 +1608,8 @@
  * \brief Fill the sockadr with IPv4 miniserver information.
  */
 static void get_server_addr(
+    /*! [in] index of the interface. */
+    int index,
 	/*! [out] pointer to server address structure. */
 	struct sockaddr *serverAddr)
 {
@@ -1484,7 +1618,7 @@
     memset( serverAddr, 0, sizeof(struct sockaddr_storage) );
 
     sa4->sin_family = AF_INET;
-    inet_pton( AF_INET, gIF_IPV4, &sa4->sin_addr );
+    inet_pton( AF_INET, gIFIP_IPV4[index], &sa4->sin_addr );
     sa4->sin_port = htons( LOCAL_PORT_V4 );
 }
 
@@ -1595,7 +1729,7 @@
 			strncpy(aliasStr, temp_str, sizeof(aliasStr) - 1);
 		}
 		if (AddressFamily == AF_INET) {
-			get_server_addr((struct sockaddr *)&serverAddr);
+            get_server_addr(0, (struct sockaddr *)&serverAddr);
 		} else {
 			get_server_addr6((struct sockaddr *)&serverAddr);
 		}
@@ -1620,7 +1754,7 @@
 
 	assert(*xmlDoc != NULL);
 
-	return UPNP_E_SUCCESS;
+    return UPNP_E_SUCCESS;
 }
 
 
@@ -3354,7 +3488,8 @@
 			   "Failed to find an adapter with valid IP addresses for use.\n");
 		return UPNP_E_INVALID_INTERFACE;
 	}
-	inet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));
+    gIFIP_IPV4[0] = gIFIP_IPV4_MEMORY;
+    inet_ntop(AF_INET, &v4_addr, gIFIP_IPV4[0], INET_ADDRSTRLEN);
 	inet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));
 #elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)
 	struct ifaddrs *ifap, *ifa;
@@ -3435,7 +3570,8 @@
 			   "Failed to find an adapter with valid IP addresses for use.\n");
 		return UPNP_E_INVALID_INTERFACE;
 	}
-	inet_ntop(AF_INET, &v4_addr, gIF_IPV4, sizeof(gIF_IPV4));
+    gIFIP_IPV4[0] = gIFIP_IPV4_MEMORY;
+    inet_ntop(AF_INET, &v4_addr, gIFIP_IPV4[0], INET_ADDRSTRLEN);
 	inet_ntop(AF_INET6, &v6_addr, gIF_IPV6, sizeof(gIF_IPV6));
 	gIF_INDEX = if_nametoindex(gIF_NAME);
 #else
@@ -3516,9 +3652,10 @@
 			/* Copy interface name, IPv4 address and interface index. */
 			memset(gIF_NAME, 0, sizeof(gIF_NAME));
 			strncpy(gIF_NAME, pifReq->ifr_name, sizeof(gIF_NAME) - 1);
-			inet_ntop(AF_INET,
+            gIFIP_IPV4[0] = gIFIP_IPV4_MEMORY;
+            inet_ntop(AF_INET,
 				  &((struct sockaddr_in *)&pifReq->ifr_addr)->
-				  sin_addr, gIF_IPV4, sizeof(gIF_IPV4));
+                      sin_addr, gIFIP_IPV4[0], INET_ADDRSTRLEN);
 			gIF_INDEX = if_nametoindex(gIF_NAME);
 			valid_addr_found = 1;
 			break;
@@ -3585,7 +3722,7 @@
 #endif
 	UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
 		   "Interface name=%s, index=%d, v4=%s, v6=%s, ULA or GUA v6=%s\n",
-		   gIF_NAME, gIF_INDEX, gIF_IPV4, gIF_IPV6, gIF_IPV6_ULA_GUA);
+               gIF_NAME, gIF_INDEX, gIFIP_IPV4[0] ? gIFIP_IPV4[0] : "", gIF_IPV6, gIF_IPV6_ULA_GUA);
 
 	return UPNP_E_SUCCESS;
 }
@@ -3714,61 +3851,93 @@
 	return ((struct Handle_Info *)HandleTable[Hnd])->Callback;
 }
 
+int IsBoundAddress(
+    unsigned src_addr)
+{
+    unsigned if_addr, if_netmask;
+    int i;
+
+    for (i = 0; gIFIP_IPV4[i] && gIFNM_IPV4[i] && (i < MAX_INTERFACES); i++) {
+        if_addr = inet_addr(gIFIP_IPV4[i]);
+        if_netmask = inet_addr(gIFNM_IPV4[i]);
+        if ((if_addr & if_netmask) == (src_addr & if_netmask)) {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+void DetermineHost(
+    unsigned src_addr,
+    char *host,
+    size_t host_len)
+{
+    unsigned if_addr, if_netmask;
+    int i;
+
+    for (i = 0; gIFIP_IPV4[i] && gIFNM_IPV4[i] && (i < MAX_INTERFACES); i++) {
+        if_addr = inet_addr(gIFIP_IPV4[i]);
+        if_netmask = inet_addr(gIFNM_IPV4[i]);
+        if ((if_addr & if_netmask) == (src_addr & if_netmask)) {
+            strncpy(host, gIFIP_IPV4[i], host_len);
+        }
+    }
+}
 
 /* Assumes at most one client */
 Upnp_Handle_Type GetClientHandleInfo(
 	UpnpClient_Handle *client_handle_out,
 	struct Handle_Info **HndInfo)
 {
-	Upnp_Handle_Type ret = HND_CLIENT;
+    Upnp_Handle_Type ret = HND_INVALID;
 	UpnpClient_Handle client;
 
-	switch (GetHandleInfo(1, HndInfo)) {
-	case HND_CLIENT:
-		client = 1;
+    *client_handle_out = -1;
+
+    for (client = 0; (client < NUM_HANDLE) && (ret == HND_INVALID); client++)
+    if (GetHandleInfo(client, HndInfo) == HND_CLIENT) {
+        ret = HND_CLIENT;
+        *client_handle_out = client;
 		break;
-	default:
-		switch (GetHandleInfo(2, HndInfo)) {
-		case HND_CLIENT:
-			client = 2;
-			break;
-		default:
-			client = -1;
-			ret = HND_INVALID;
-		}
 	}
 
-	*client_handle_out = client;
 	return ret;
 }
 
 
 Upnp_Handle_Type GetDeviceHandleInfo(
-	int AddressFamily,
-	UpnpDevice_Handle *device_handle_out,
+    const char *host,
+    const char *path,
+    UpnpDevice_Handle *device_handle_out,
 	struct Handle_Info **HndInfo)
 {
-#ifdef INCLUDE_DEVICE_APIS
-	/* Check if we've got a registered device of the address family specified. */
-	if ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||
-	    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {
-		*device_handle_out = -1;
-		return HND_INVALID;
-	}
+    char *pos, *end;
 
-	/* Find it. */
-	for (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {
-		switch (GetHandleInfo(*device_handle_out, HndInfo)) {
-		case HND_DEVICE:
-			if ((*HndInfo)->DeviceAf == AddressFamily) {
-				return HND_DEVICE;
-			}
-			break;
-		default:
-			break;
-		}
-	}
+    if (host == NULL) {
+        UpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,
+            "GetDeviceHandleInfo: host is NULL\n");
+    } else {
+#ifdef INCLUDE_DEVICE_APIS
+        /* Find it. */
+        for (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {
+            switch (GetHandleInfo(*device_handle_out, HndInfo)) {
+            case HND_DEVICE:
+                pos = strstr((*HndInfo)->DescURL, "://");
+                if (pos && (strncmp(pos + 3, host, strlen(host)) == 0)) {
+                    pos += 3 + strlen(host);
+                    end = strrchr(pos, '/');
+                    if (end && (strncmp(pos, path, end - pos + 1) == 0)) {
+                        return HND_DEVICE;
+                    }
+                }
+                break;
+            default:
+                break;
+            }
+        }
 #endif /* INCLUDE_DEVICE_APIS */
+    }
 
 	*device_handle_out = -1;
 	return HND_INVALID;
@@ -3828,36 +3997,59 @@
 }
 
 
-int getlocalhostname(char *out, size_t out_len)
+int getlocalhostnames(char *out, char *out_nm, size_t out_len)
 {
-	int ret = UPNP_E_SUCCESS;
+    int ret = UPNP_E_SUCCESS;
+    size_t out_pos = 0;
 	char tempstr[INET_ADDRSTRLEN];
 	const char *p = NULL;
 
 #ifdef WIN32
-	struct hostent *h = NULL;
-	struct sockaddr_in LocalAddr;
+    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);
+    INTERFACE_INFO interfaceInfo[MAX_INTERFACES];
+    DWORD bytes = 0;
+    struct sockaddr_in *LocalAddr;
+    unsigned i;
+
+    memset(interfaceInfo, 0, sizeof(interfaceInfo));
+    if (WSAIoctl(sock, SIO_GET_INTERFACE_LIST,
+        0, 0, interfaceInfo, sizeof(interfaceInfo),
+        &bytes, 0, 0) != SOCKET_ERROR) {
+        for (i = 0; (i < bytes / sizeof(*interfaceInfo)) && (i < MAX_INTERFACES) && (out_pos < out_len); i++) {
+            /* Get a pointer to the address...*/
+            LocalAddr = ((struct sockaddr_in *)&interfaceInfo[i].iiAddress);
+            if (LocalAddr->sin_family == AF_INET) {
+                p = inet_ntop(AF_INET, &LocalAddr->sin_addr, tempstr, sizeof(tempstr));
+                if (p) {
+                    strncpy(out + out_pos, p, INET_ADDRSTRLEN - 1);
 
-	memset(&LocalAddr, 0, sizeof(LocalAddr));
+                    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
+                        "Inside getlocalhostname: after strncpy %s\n", out + out_pos);
 
-	gethostname(out, out_len);
-	h = gethostbyname(out);
-	if (h != NULL) {
-		memcpy(&LocalAddr.sin_addr, h->h_addr_list[0], 4);
-		p = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));
-		if (p) {
-			strncpy(out, p, out_len);
-		} else {
-			UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,
-				"getlocalhostname: inet_ntop returned error\n" );
-			ret = UPNP_E_INIT;
-		}
-	} else {
-		UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,
-			"getlocalhostname: gethostbyname returned error\n" );
-		ret = UPNP_E_INIT;
-	}
+                    /* Get a pointer to the netmask...*/
+                    LocalAddr = ((struct sockaddr_in *)&interfaceInfo[i].iiNetmask);
 
+                    p = inet_ntop(AF_INET, &LocalAddr->sin_addr, tempstr, sizeof(tempstr));
+                    if (p) {
+                        strncpy(out_nm + out_pos, p, INET_ADDRSTRLEN - 1);
+                        UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
+                            "Inside getlocalhostname: after strncpy %s\n", out + out_pos);
+                        out_pos += INET_ADDRSTRLEN;
+                    } else {
+                        UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,
+                            "getlocalhostname: inet_ntop returned error\n" );
+                        ret = UPNP_E_INIT;
+                    }
+                } else {
+                    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,
+                        "getlocalhostname: inet_ntop returned error\n" );
+                    ret = UPNP_E_INIT;
+                }
+            }
+        }
+    }
+
+    closesocket(sock);
 #elif (defined(BSD) && BSD >= 199306) || defined(__FreeBSD_kernel__)
 	struct ifaddrs *ifap, *ifa;
 
@@ -3868,33 +4060,37 @@
 	}
 
 	/* cycle through available interfaces */
-	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
-		/* Skip loopback, point-to-point and down interfaces, 
-		 * except don't skip down interfaces
-		 * if we're trying to get a list of configurable interfaces. */
-		if ((ifa->ifa_flags & IFF_LOOPBACK) ||
-		    (!( ifa->ifa_flags & IFF_UP))) {
+    for (ifa = ifap; (ifa != NULL) && (out_pos < out_len); ifa = ifa->ifa_next) {
+        if (!( ifa->ifa_flags & IFF_UP)) {
 			continue;
 		}
 		if (ifa->ifa_addr->sa_family == AF_INET) {
-			/* We don't want the loopback interface. */
-			if (((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr.s_addr ==
-			    htonl(INADDR_LOOPBACK)) {
-				continue;
-			}
 			p = inet_ntop(AF_INET,
 				&((struct sockaddr_in *)(ifa->ifa_addr))->sin_addr,
 				tempstr, sizeof(tempstr));
 			if (p) {
-				strncpy(out, p, out_len);
-			} else {
+              strncpy(out + out_pos, p, INET_ADDRSTRLEN - 1);
+              UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
+                  "Inside getlocalhostname: after strncpy %s\n", out + out_pos);
+
+              p = inet_ntop(AF_INET,
+                  &((struct sockaddr_in *)(ifa->ifa_netmask))->sin_addr,
+                  tempstr, sizeof(tempstr));
+              if (p) {
+                strncpy(out_nm + out_pos, p, INET_ADDRSTRLEN - 1);
+                UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
+                    "Inside getlocalhostname: after strncpy %s\n", out + out_pos);
+                out_pos += INET_ADDRSTRLEN;
+              } else {
+                  UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
+                      "getlocalhostname: inet_ntop returned error\n");
+                  ret = UPNP_E_INIT;
+              }
+            } else {
 				UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
 					"getlocalhostname: inet_ntop returned error\n");
 				ret = UPNP_E_INIT;
 			}
-			UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
-				"Inside getlocalhostname: after strncpy %s\n", out);
-			break;
 		}
 	}
 	freeifaddrs(ifap);
@@ -3908,7 +4104,6 @@
 	long unsigned int i;
 	int LocalSock;
 	struct sockaddr_in LocalAddr;
-	int j = 0;
 
 	/* purify */
 	memset(&ifConf,  0, sizeof(ifConf));
@@ -3935,7 +4130,7 @@
 	}
 
 	/* Cycle through the list of interfaces looking for IP addresses. */
-	for (i = 0lu; i < (long unsigned int)ifConf.ifc_len && j < DEFAULT_INTERFACE; ) {
+    for (i = 0lu; (i < (long unsigned int)ifConf.ifc_len) && (out_pos < out_len); ) {
 		struct ifreq *pifReq =
 			(struct ifreq *)((caddr_t)ifConf.ifc_req + i);
 		i += sizeof *pifReq;
@@ -3948,41 +4143,53 @@
 				"Can't get interface flags for %s:\n",
 				ifReq.ifr_name);
 		}
-		/* Skip loopback, point-to-point and down interfaces,
-		 * except don't skip down interfaces
-		 * if we're trying to get a list of configurable interfaces. */
-		if ((ifReq.ifr_flags & IFF_LOOPBACK) ||
-		    (!(ifReq.ifr_flags & IFF_UP))) {
+        if (!(ifReq.ifr_flags & IFF_UP)) {
 			continue;
 		}
 		if (pifReq->ifr_addr.sa_family == AF_INET) {
 			/* Get a pointer to the address...*/
 			memcpy(&LocalAddr, &pifReq->ifr_addr,
 				sizeof pifReq->ifr_addr);
-			/* We don't want the loopback interface. */
-			if (LocalAddr.sin_addr.s_addr ==
-			    htonl(INADDR_LOOPBACK)) {
-				continue;
-			}
-		}
-		/* increment j if we found an address which is not loopback
-		 * and is up */
-		j++;
+
+            p = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));
+            if (p) {
+                strncpy(out + out_pos, p, INET_ADDRSTRLEN - 1);
+
+                /* Get a pointer to the netmask...*/
+                if (ioctl(LocalSock, SIOCGIFNETMASK, &ifReq) < 0) {
+                    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
+                        "Can't get netmask for %s:\n",
+                        ifReq.ifr_name);
+                }
+
+                memcpy(&LocalAddr, &ifReq.ifr_netmask,
+                    sizeof ifReq.ifr_netmask);
+
+                UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
+                    "Inside getlocalhostname: after strncpy %s\n", out + out_pos);
+
+                p = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));
+                if (p) {
+                    strncpy(out_nm + out_pos, p, INET_ADDRSTRLEN - 1);
+                    UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
+                        "Inside getlocalhostname: after strncpy %s\n", out + out_pos);
+                    out_pos += INET_ADDRSTRLEN;
+                } else {
+                    UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,
+                        "getlocalhostname: inet_ntop returned error\n" );
+                    ret = UPNP_E_INIT;
+                }
+            } else {
+                UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,
+                    "getlocalhostname: inet_ntop returned error\n" );
+                ret = UPNP_E_INIT;
+            }
+        }
 	}
 	close(LocalSock);
 
-	p = inet_ntop(AF_INET, &LocalAddr.sin_addr, tempstr, sizeof(tempstr));
-	if (p) {
-		strncpy(out, p, out_len);
-	} else {
-		UpnpPrintf( UPNP_ALL, API, __FILE__, __LINE__,
-			"getlocalhostname: inet_ntop returned error\n" );
-		ret = UPNP_E_INIT;
-	}
-	UpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__,
-		"Inside getlocalhostname: after strncpy %s\n", out);
 #endif
-	return ret;
+    return (ret < UPNP_E_SUCCESS) ? ret : (int)(out_pos / INET_ADDRSTRLEN);
 }
 
 
--- upnp/src/gena/gena_ctrlpt.c	2013-11-15 17:01:35.000000000 +0100
+++ upnp/src/gena/gena_ctrlpt.c	2014-06-15 11:42:31.768992150 +0200
@@ -351,7 +351,7 @@
 				&request, 1, 1,
 				"q" "sssdsc" "sc" "sscc",
 				HTTPMETHOD_SUBSCRIBE, &dest_url,
-				"CALLBACK: <http://", gIF_IPV4, ":", LOCAL_PORT_V4, "/>",
+                        "CALLBACK: <http://", gIFIP_IPV4[0], ":", LOCAL_PORT_V4, "/>",
 				"NT: upnp:event",
 				"TIMEOUT: Second-", timeout_str);
 		}
--- upnp/src/gena/gena_device.c	2013-11-15 17:01:35.000000000 +0100
+++ upnp/src/gena/gena_device.c	2014-06-15 12:02:29.797026396 +0200
@@ -210,7 +210,7 @@
 	}
 	timeout = GENA_NOTIFICATION_SENDING_TIMEOUT;
 	/* send msg (note: end of notification will contain "\r\n" twice) */
-	ret_code = http_SendMessage(&info, &timeout,
+    ret_code = http_SendMessage(&info, &timeout,
 		"bbb",
 		start_msg.buf, start_msg.length,
 		propertySet, strlen(propertySet),
@@ -1207,7 +1207,7 @@
 	SOCKINFO *info,
 	http_message_t *request)
 {
-	struct Upnp_Subscription_Request request_struct;
+    struct Upnp_Subscription_Request request_struct;
 	Upnp_SID temp_sid;
 	int return_code = 1;
 	int time_out = 1801;
@@ -1229,10 +1229,14 @@
 	UpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,
 		"Subscription Request Received:\n");
 
-	if (httpmsg_find_hdr(request, HDR_NT, &nt_hdr) == NULL) {
-		error_respond(info, HTTP_BAD_REQUEST, request);
-		goto exit_function;
-	}
+    /* get host header */
+    strncpy(request_struct.Host, request->host, sizeof(request_struct.Host) - 1);
+    request_struct.Host[sizeof(request_struct.Host) - 1] = '\0';
+
+    if (httpmsg_find_hdr(request, HDR_NT, &nt_hdr) == NULL) {
+        error_respond(info, HTTP_BAD_REQUEST, request);
+        goto exit_function;
+    }
 
 	/* check NT header */
 	/* Windows Millenium Interoperability: */
@@ -1260,8 +1264,8 @@
 
 	HandleLock();
 
-	/* CURRENTLY, ONLY ONE DEVICE */
-	if (GetDeviceHandleInfo(info->foreign_sockaddr.ss_family , 
+    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */
+    if (GetDeviceHandleInfo(request->host, event_url_path,
 	    &device_handle, &handle_info) != HND_DEVICE) {
 		free(event_url_path);
 		error_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);
@@ -1431,8 +1435,7 @@
 
     HandleLock();
 
-    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */
-    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,
+    if( GetDeviceHandleInfo( request->host, event_url_path.buf,
         &device_handle, &handle_info ) != HND_DEVICE ) {
         error_respond( info, HTTP_PRECONDITION_FAILED, request );
         membuffer_destroy( &event_url_path );
@@ -1542,8 +1545,7 @@
 
     HandleLock();
 
-    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */
-    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,
+    if( GetDeviceHandleInfo( request->host, event_url_path.buf,
         &device_handle, &handle_info ) != HND_DEVICE ) {
         error_respond( info, HTTP_PRECONDITION_FAILED, request );
         membuffer_destroy( &event_url_path );
--- upnp/src/genlib/miniserver/miniserver.c	2014-06-15 11:41:34.376990000 +0200
+++ upnp/src/genlib/miniserver/miniserver.c	2014-06-15 11:42:31.768992150 +0200
@@ -201,7 +201,8 @@
 	int ret_code;
 	int major = 1;
 	int minor = 1;
-	http_parser_t parser;
+    memptr host;
+    http_parser_t parser;
 	http_message_t *hmsg = NULL;
 	int timeout = HTTP_DEFAULT_TIMEOUT;
 	struct mserv_request_t *request = (struct mserv_request_t *)args;
@@ -224,7 +225,22 @@
 	if (ret_code != 0) {
 		goto error_handler;
 	}
-	UpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,
+    /* Determine host */
+    parser.msg.host[0] = parser.msg.host[sizeof(parser.msg.host) - 1] = '\0';
+    if (httpmsg_find_hdr(&parser.msg, HDR_HOST, &host) != NULL) {
+        strncpy(parser.msg.host, host.buf, sizeof(parser.msg.host) - 1);
+    } else {
+        DetermineHost(((struct sockaddr_in *)&request->foreign_sockaddr)->sin_addr.s_addr, parser.msg.host, sizeof(parser.msg.host) - 1);
+    }
+    if (parser.msg.host[0] == '\0') {
+        strncpy(parser.msg.host, gIFIP_IPV4[0], sizeof(parser.msg.host) - 1);
+    }
+    if (strchr(parser.msg.host, ':') == NULL) {
+        sprintf(
+            parser.msg.host + strlen(parser.msg.host),
+            ":%d", LOCAL_PORT_V4);
+    }
+    UpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,
 		"miniserver %d: PROCESSING...\n", connfd);
 	/* dispatch */
 	http_error_code = dispatch_request(&info, &parser);
@@ -308,7 +324,12 @@
 		clientLen = sizeof(clientAddr);
 		asock = accept(lsock, (struct sockaddr *)&clientAddr,
 			&clientLen);
-		if (asock == INVALID_SOCKET) {
+        if (!IsBoundAddress(((struct sockaddr_in *)&clientAddr)->sin_addr.s_addr)) {
+            sock_close(asock);
+            UpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,
+                "miniserver: Refused incoming connection\n");
+        }
+        else if (asock == INVALID_SOCKET) {
 			strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
 			UpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,
 				"miniserver: Error in accept(): %s\n",
--- upnp/src/genlib/net/http/httpreadwrite.c	2013-11-15 17:01:35.000000000 +0100
+++ upnp/src/genlib/net/http/httpreadwrite.c	2014-06-15 11:42:31.772992150 +0200
@@ -379,8 +379,9 @@
 #if EXCLUDE_WEB_SERVER == 0
 	FILE *Fp;
 	struct SendInstruction *Instr = NULL;
-	char *filename = NULL;
-	char *file_buf = NULL;
+    struct Request_Info *rinfo;
+    char *filename = NULL;
+    char *file_buf = NULL;
 	char *ChunkBuf = NULL;
 	/* 10 byte allocated for chunk header. */
 	char Chunk_Header[CHUNK_HEADER_SIZE];
@@ -420,10 +421,11 @@
 			file_buf = ChunkBuf + CHUNK_HEADER_SIZE;
 		} else if (c == 'f') {
 			/* file name */
-			filename = va_arg(argp, char *);
-			if (Instr && Instr->IsVirtualFile)
-				Fp = (virtualDirCallback.open)(filename, UPNP_READ);
-			else
+            rinfo = va_arg(argp, struct Request_Info *);
+            filename = va_arg(argp, char *);
+            if (Instr && Instr->IsVirtualFile)
+                Fp = (virtualDirCallback.open)(rinfo, filename, UPNP_READ);
+            else
 				Fp = fopen(filename, "rb");
 			if (Fp == NULL) {
 				RetVal = UPNP_E_FILE_READ_ERROR;
@@ -613,7 +615,7 @@
 		goto end_function;
 	}
 	/* send request */
-	ret_code = http_SendMessage(&info, &timeout_secs, "b",
+    ret_code = http_SendMessage(&info, &timeout_secs, "b",
 		request, request_length);
 	if (ret_code != 0) {
 		parser_response_init(response, req_method);
@@ -1042,7 +1044,7 @@
 		goto errorHandler;
 	}
 	/* send request */
-	ret_code = http_SendMessage(&handle->sock_info, &timeout, "b",
+    ret_code = http_SendMessage(&handle->sock_info, &timeout, "b",
 				    request.buf, request.length);
 	if (ret_code != 0)
 		sock_destroy(&handle->sock_info, SD_BOTH);
@@ -1536,7 +1538,7 @@
 		goto errorHandler;
 	}
 	/* send request */
-	ret_code = http_SendMessage(&handle->sock_info, &timeout, "b",
+    ret_code = http_SendMessage(&handle->sock_info, &timeout, "b",
 				    request.buf, request.length);
 	if (ret_code) {
 		sock_destroy(&handle->sock_info, SD_BOTH);
@@ -1618,7 +1620,7 @@
 			       http_status_code, http_status_code);
 	if (ret == 0) {
 		timeout = HTTP_DEFAULT_TIMEOUT;
-		ret = http_SendMessage(info, &timeout, "b",
+        ret = http_SendMessage(info, &timeout, "b",
 		       membuf.buf, membuf.length);
 	}
 	membuffer_destroy(&membuf);
@@ -2079,7 +2081,7 @@
 			break;
 		}
 		/* send request */
-		errCode = http_SendMessage(&handle->sock_info, &timeout,
+        errCode = http_SendMessage(&handle->sock_info, &timeout,
 			"b", request.buf, request.length);
 		if (errCode != UPNP_E_SUCCESS) {
 			sock_destroy(&handle->sock_info, SD_BOTH);
--- upnp/src/genlib/net/http/webserver.c	2014-06-15 11:42:00.524991000 +0200
+++ upnp/src/genlib/net/http/webserver.c	2014-06-15 11:42:31.772992150 +0200
@@ -1026,7 +1026,9 @@
 static int process_request(
 	/*! [in] HTTP Request message. */
 	http_message_t *req,
-	/*! [out] Tpye of response. */
+    /*! [in] Socket information object. */
+    SOCKINFO *info,
+    /*! [out] Tpye of response. */
 	enum resp_type *rtype,
 	/*! [out] Headers. */
 	membuffer *headers,
@@ -1041,6 +1043,7 @@
 	int err_code;
 
 	char *request_doc;
+    struct Request_Info rinfo;
 	struct File_Info finfo;
 	int using_alias;
 	int using_virtual_dir;
@@ -1051,6 +1054,8 @@
 	int alias_grabbed;
 	size_t dummy;
 	const char *extra_headers = NULL;
+    memptr userAgent;
+    struct sockaddr_in *inAddr;
 
 	print_http_headers(req);
 	url = &req->uri;
@@ -1114,9 +1119,18 @@
 	}
 	if (using_virtual_dir) {
 		if (req->method != HTTPMETHOD_POST) {
-			/* get file info */
+            rinfo.host[0] = rinfo.host[sizeof(rinfo.host) - 1] = '\0';
+            strncpy(rinfo.host, req->host, sizeof(rinfo.host) - 1);
+            rinfo.userAgent[0] = rinfo.userAgent[sizeof(rinfo.userAgent) - 1] = '\0';
+            if (httpmsg_find_hdr(req, HDR_USER_AGENT, &userAgent))
+                strncpy(rinfo.userAgent, userAgent.buf, sizeof(rinfo.userAgent) - 1);
+            inAddr = ((struct sockaddr_in *)&info->foreign_sockaddr);
+            if (inet_ntop(inAddr->sin_family, &inAddr->sin_addr, rinfo.sourceAddress, sizeof(rinfo.sourceAddress)) == NULL)
+                rinfo.sourceAddress[0] = '\0';
+
+            /* get file info */
 			if (virtualDirCallback.
-			    get_info(filename->buf, &finfo) != 0) {
+                get_info(&rinfo, filename->buf, &finfo) != 0) {
 				err_code = HTTP_NOT_FOUND;
 				goto error_handler;
 			}
@@ -1130,10 +1144,10 @@
 				if (membuffer_append_str(filename, temp_str) !=
 				    0) {
 					goto error_handler;
-				}
+                }
 				/* get info */
 				if ((virtualDirCallback.
-				     get_info(filename->buf,
+                     get_info(&rinfo, filename->buf,
 					      &finfo) != UPNP_E_SUCCESS)
 				    || finfo.is_directory) {
 					err_code = HTTP_NOT_FOUND;
@@ -1353,7 +1367,7 @@
 	SOCKINFO *info,
 	/*! File where received data is copied to. */
 	char *filename,
-	/*! Send Instruction object which gives information whether the file
+    /*! Send Instruction object which gives information whether the file
 	 * is a virtual file or not. */
 	struct SendInstruction *Instr)
 {
@@ -1361,14 +1375,26 @@
 	char Buf[1024];
 	int Timeout = 0;
 	FILE *Fp;
+    struct Request_Info rinfo;
 	parse_status_t status = PARSE_OK;
 	int ok_on_close = FALSE;
 	size_t entity_offset = 0;
 	int num_read = 0;
 	int ret_code = HTTP_OK;
+    memptr userAgent;
+    struct sockaddr_in *inAddr;
 
 	if (Instr && Instr->IsVirtualFile) {
-		Fp = (virtualDirCallback.open) (filename, UPNP_WRITE);
+        rinfo.host[0] = rinfo.host[sizeof(rinfo.host) - 1] = '\0';
+        strncpy(rinfo.host, parser->msg.host, sizeof(rinfo.host) - 1);
+        rinfo.userAgent[0] = rinfo.userAgent[sizeof(rinfo.userAgent) - 1] = '\0';
+        if (httpmsg_find_hdr(&parser->msg, HDR_USER_AGENT, &userAgent))
+            strncpy(rinfo.userAgent, userAgent.buf, sizeof(rinfo.userAgent) - 1);
+        inAddr = ((struct sockaddr_in *)&info->foreign_sockaddr);
+        if (inet_ntop(inAddr->sin_family, &inAddr->sin_addr, rinfo.sourceAddress, sizeof(rinfo.sourceAddress)) == NULL)
+            rinfo.sourceAddress[0] = '\0';
+
+        Fp = (virtualDirCallback.open) (&rinfo, filename, UPNP_WRITE);
 		if (Fp == NULL)
 			return HTTP_INTERNAL_SERVER_ERROR;
 	} else {
@@ -1476,6 +1502,9 @@
 	membuffer filename;
 	struct xml_alias_t xmldoc;
 	struct SendInstruction RespInstr;
+    memptr userAgent;
+    struct Request_Info rinfo;
+    struct sockaddr_in *inAddr;
 
 	/*Initialize instruction header. */
 	RespInstr.IsVirtualFile = 0;
@@ -1490,23 +1519,32 @@
 
 	/*Process request should create the different kind of header depending on the */
 	/*the type of request. */
-	ret = process_request(req, &rtype, &headers, &filename, &xmldoc,
+    ret = process_request(req, info, &rtype, &headers, &filename, &xmldoc,
 		&RespInstr);
 	if (ret != HTTP_OK) {
 		/* send error code */
 		http_SendStatusResponse(info, ret, req->major_version,
 			req->minor_version);
 	} else {
+        rinfo.host[0] = rinfo.host[sizeof(rinfo.host) - 1] = '\0';
+        strncpy(rinfo.host, req->host, sizeof(rinfo.host) - 1);
+        rinfo.userAgent[0] = rinfo.userAgent[sizeof(rinfo.userAgent) - 1] = '\0';
+        if (httpmsg_find_hdr(req, HDR_USER_AGENT, &userAgent))
+            strncpy(rinfo.userAgent, userAgent.buf, sizeof(rinfo.userAgent) - 1);
+        inAddr = ((struct sockaddr_in *)&info->foreign_sockaddr);
+        if (inet_ntop(inAddr->sin_family, &inAddr->sin_addr, rinfo.sourceAddress, sizeof(rinfo.sourceAddress)) == NULL)
+            rinfo.sourceAddress[0] = '\0';
+
 		/* send response */
 		switch (rtype) {
 		case RESP_FILEDOC:
-			http_SendMessage(info, &timeout, "Ibf",
+            http_SendMessage(info, &timeout, "Ibf",
 					 &RespInstr,
 					 headers.buf, headers.length,
-					 filename.buf);
+                     &rinfo, filename.buf);
 			break;
 		case RESP_XMLDOC:
-			http_SendMessage(info, &timeout, "Ibb",
+            http_SendMessage(info, &timeout, "Ibb",
 				&RespInstr,
 				headers.buf, headers.length,
 				xmldoc.doc.buf, xmldoc.doc.length);
@@ -1516,26 +1554,26 @@
 			/*http_SendVirtualDirDoc(info, &timeout, "Ibf",
 				&RespInstr,
 				headers.buf, headers.length,
-				filename.buf);*/
-			http_SendMessage(info, &timeout, "Ibf",
+                &rinfo, filename.buf);*/
+            http_SendMessage(info, &timeout, "Ibf",
 				&RespInstr,
 				headers.buf, headers.length,
-				filename.buf);
+                &rinfo, filename.buf);
 			break;
 		case RESP_HEADERS:
 			/* headers only */
-			http_SendMessage(info, &timeout, "b",
+            http_SendMessage(info, &timeout, "b",
 				headers.buf, headers.length);
 			break;
 		case RESP_POST:
 			/* headers only */
-			ret = http_RecvPostMessage(parser, info, filename.buf,
+            ret = http_RecvPostMessage(parser, info, filename.buf,
 				&RespInstr);
 			/* Send response. */
 			http_MakeMessage(&headers, 1, 1,
 				"RTLSXcCc",
 				ret, "text/html", &RespInstr, X_USER_AGENT);
-			http_SendMessage(info, &timeout, "b",
+            http_SendMessage(info, &timeout, "b",
 				headers.buf, headers.length);
 			break;
 		default:
--- upnp/src/inc/httpparser.h	2013-11-15 17:01:35.000000000 +0100
+++ upnp/src/inc/httpparser.h	2014-06-15 11:42:31.772992150 +0200
@@ -174,6 +174,8 @@
 
 typedef struct {
 	int initialized;
+    /*! host, determined either from the host field or the source address. */
+    char host[LINE_SIZE];
 	/*! request only. */
 	http_method_t method;
 	/*! request only. */
--- upnp/src/inc/httpreadwrite.h	2013-11-15 17:01:35.000000000 +0100
+++ upnp/src/inc/httpreadwrite.h	2014-06-15 11:42:31.772992150 +0200
@@ -130,17 +130,19 @@
  * \brief Sends a message to the destination based on the format parameter.
  *
  * fmt types:
- * \li \c 'f': arg = "const char *" file name
+ * \li \c 'f': arg1 = "struct Request_Info *" Request_Info structure for this request; arg2 = "const char *" file name.
  * \li \c 'b': arg1 = "const char *" mem_buffer; arg2 = "size_t" buffer length.
  * \li \c 'I': arg = "struct SendInstruction *"
  *
  * E.g.:
  \verbatim
  	char *buf = "POST /xyz.cgi http/1.1\r\n\r\n";
- 	char *filename = "foo.dat";
+    char *host = "127.0.0.1:1234";
+    char *userAgent = "bar";
+    char *filename = "foo.dat";
  	int status = http_SendMessage(tcpsock, "bf",
  		buf, strlen(buf),	// args for memory buffer
- 		filename);		// arg for file
+        host, userAgent, filename);	// args for file
  \endverbatim
  *
  * \return
@@ -149,14 +151,14 @@
  * \li \c UPNP_E_SUCCESS
  */
 int http_SendMessage(
-	/* [in] Socket information object. */
-	SOCKINFO *info,
-	/* [in,out] Time out value. */
-	int* timeout_secs, 
-	/* [in] Pattern format to take actions upon. */
-	const char* fmt,
-	/* [in] Variable parameter list. */
-	...);
+    /* [in] Socket information object. */
+    SOCKINFO *info,
+    /* [in,out] Time out value. */
+    int* timeout_secs,
+    /* [in] Pattern format to take actions upon. */
+    const char* fmt,
+    /* [in] Variable parameter list. */
+    ...);
 
 /************************************************************************
  * Function: http_RequestAndResponse
--- upnp/src/inc/upnpapi.h	2013-11-15 17:01:35.000000000 +0100
+++ upnp/src/inc/upnpapi.h	2014-06-15 11:55:43.589014784 +0200
@@ -45,7 +45,7 @@
 #include "VirtualDir.h"		/* for struct VirtualDirCallbacks */
 
 
-#define MAX_INTERFACES 256
+#define MAX_INTERFACES 16
 
 #define DEFAULT_INTERFACE 1
 
@@ -155,6 +155,26 @@
 
 
 /*!
+ * \brief Returns nonzero when the address if from one of the bound interfaces.
+ */
+int IsBoundAddress(
+    /*! [in] Source IP address. */
+    unsigned src_addr);
+
+/*!
+ * \brief Determines the host string.
+ *
+ * \return host address
+ */
+void DetermineHost(
+    /*! [in] Source IP address. */
+    unsigned src_addr,
+    /*! [out] Destination host string. */
+    char *host,
+    /*! [in] Destination host string length. */
+    size_t host_len);
+
+/*!
  * \brief Get client handle info.
  *
  * \note The logic around the use of this function should be revised.
@@ -173,9 +193,11 @@
  * \return HND_DEVICE or HND_INVALID
  */
 Upnp_Handle_Type GetDeviceHandleInfo(
-	/*! [in] Address family. */
-	int AddressFamily,
-	/*! [out] Device handle pointer. */
+    /*! The IP address (and optionally) port used to perform this request. */
+    const char *host,
+    /*! The path to the service for this request. */
+    const char *path,
+    /*! [out] Device handle pointer. */
 	int *device_handle_out, 
 	/*! [out] Device handle structure passed by this function. */
 	struct Handle_Info **HndInfo);
@@ -180,9 +202,9 @@
 	/*! [out] Device handle structure passed by this function. */
 	struct Handle_Info **HndInfo);
 
-
 extern char gIF_NAME[LINE_SIZE];
-extern char gIF_IPV4[INET_ADDRSTRLEN];
+extern char * gIFIP_IPV4[MAX_INTERFACES + 1];
+extern char * gIFNM_IPV4[MAX_INTERFACES + 1];
 extern char gIF_IPV6[INET6_ADDRSTRLEN];
 
 extern char gIF_IPV6_ULA_GUA[INET6_ADDRSTRLEN];
@@ -289,18 +311,20 @@
 
 
 /*!
- * \brief Get local IP address.
+ * \brief Get local IP addresses.
  *
- * Gets the ip address for the DEFAULT_INTERFACE interface which is up and not
- * a loopback. Assumes at most MAX_INTERFACES interfaces
+ * Gets the ip addresses for the interfaces which are up.
+ * Assumes at most MAX_INTERFACES interfaces
  *
  * \return UPNP_E_SUCCESS  if successful or UPNP_E_INIT.
  */
-int getlocalhostname(
-	/*! [out] IP address of the interface. */
-	char *out,
-	/*! [in] Length of the output buffer. */
-	size_t out_len);
+int getlocalhostnames(
+    /*! [out] IP addresses of the interfaces. */
+    char *out,
+    /*! [out] netmask addresses of the interfaces. */
+    char *out_nm,
+    /*! [in] Length of the output buffer. */
+    size_t out_len);
 
 
 /*!
--- upnp/src/soap/soap_device.c	2013-11-15 17:01:35.000000000 +0100
+++ upnp/src/soap/soap_device.c	2014-06-15 12:02:06.857025740 +0200
@@ -214,7 +214,7 @@
 		return;
 	}
 	/* send err msg */
-	http_SendMessage(info, &timeout_secs, "b",
+    http_SendMessage(info, &timeout_secs, "b",
 		headers.buf, headers.length);
 	membuffer_destroy(&headers);
 }
@@ -265,7 +265,7 @@
 		return;
 	}
 	/* send msg */
-	http_SendMessage(info, &timeout_secs, "b",
+    http_SendMessage(info, &timeout_secs, "b",
 		response.buf, response.length);
 	membuffer_destroy(&response);
 }
@@ -475,8 +475,6 @@
 	int isQuery,
 	/*! [in] Action request document. */
 	IXML_Document *actionDoc,
-	/*! [in] . */
-	int AddressFamily,
 	/*! [out] Device UDN string. */
 	OUT char device_udn[LINE_SIZE],
 	/*! [out] Service ID string. */
@@ -502,7 +500,7 @@
 
 	HandleLock();
 
-	if (GetDeviceHandleInfo(AddressFamily, &device_hnd,
+    if (GetDeviceHandleInfo(request->host, control_url, &device_hnd,
 				&device_info) != HND_DEVICE)
 		goto error_handler;
 	serv_info = FindServiceControlURLPath(
@@ -600,7 +598,7 @@
 	}
 	/* send whole msg */
 	ret_code = http_SendMessage(
-		info, &timeout_secs, "bbbb",
+        info, &timeout_secs, "bbbb",
 		headers.buf, headers.length,
 		start_body, strlen(start_body),
 		xml_response, strlen(xml_response),
@@ -702,7 +700,6 @@
 	}
 	/* get info for event */
 	err_code = get_device_info(request, 1, xml_doc,
-				   info->foreign_sockaddr.ss_family,
 				   variable.DevUDN,
 				   variable.ServiceID,
 				   &soap_event_callback, &cookie);
@@ -757,13 +754,25 @@
 	/*! [in] Document containing the SOAP action request. */
 	IN IXML_Document *xml_doc)
 {
-	char save_char;
+    char save_char;
 	IXML_Document *resp_node = NULL;
 	struct Upnp_Action_Request action;
 	Upnp_FunPtr soap_event_callback;
 	void *cookie = NULL;
 	int err_code;
 	const char *err_str;
+    memptr userAgent;
+    struct sockaddr_in *inAddr;
+
+    /* Get request info */
+    action.RequestInfo.host[0] = action.RequestInfo.host[sizeof(action.RequestInfo.host) - 1] = '\0';
+    strncpy(action.RequestInfo.host, request->host, sizeof(action.RequestInfo.host) - 1);
+    action.RequestInfo.userAgent[0] = action.RequestInfo.userAgent[sizeof(action.RequestInfo.userAgent) - 1] = '\0';
+    if (httpmsg_find_hdr(request, HDR_USER_AGENT, &userAgent))
+        strncpy(action.RequestInfo.userAgent, userAgent.buf, sizeof(action.RequestInfo.userAgent) - 1);
+    inAddr = ((struct sockaddr_in *)&info->foreign_sockaddr);
+    if (inet_ntop(inAddr->sin_family, &inAddr->sin_addr, action.RequestInfo.sourceAddress, sizeof(action.RequestInfo.sourceAddress)) == NULL)
+        action.RequestInfo.sourceAddress[0] = '\0';
 
 	action.ActionResult = NULL;
 	/* null-terminate */
@@ -779,7 +788,6 @@
 	err_code = get_device_info(request,
 				   0,
 				   xml_doc,
-				   info->foreign_sockaddr.ss_family,
 				   action.DevUDN,
 				   action.ServiceID,
 				   &soap_event_callback, &cookie);
--- upnp/src/ssdp/ssdp_ctrlpt.c	2013-11-15 17:01:35.000000000 +0100
+++ upnp/src/ssdp/ssdp_ctrlpt.c	2014-06-15 11:42:31.772992150 +0200
@@ -523,7 +523,7 @@
 	int handle;
 	struct Handle_Info *ctrlpt_info = NULL;
 	enum SsdpSearchType requestType;
-	unsigned long addrv4 = inet_addr(gIF_IPV4);
+    unsigned long addrv4 = inet_addr(gIFIP_IPV4[0]);
 	SOCKET max_fd = 0;
 	int retVal;
 
--- upnp/src/ssdp/ssdp_device.c	2014-06-15 11:41:43.272990000 +0200
+++ upnp/src/ssdp/ssdp_device.c	2014-06-19 21:18:45.688138693 +0200
@@ -92,7 +92,7 @@
 	SsdpSearchReply *threadArg = NULL;
 	ThreadPoolJob job;
 	int replyTime;
-	int maxAge;
+    int maxAge;
 
 	memset(&job, 0, sizeof(job));
 
@@ -117,51 +117,50 @@
 		/* bad ST header. */
 		return;
 
-	HandleLock();
-	/* device info. */
-	switch (GetDeviceHandleInfo((int)dest_addr->ss_family,
-				&handle, &dev_info)) {
-	case HND_DEVICE:
-		break;
-	default:
-		HandleUnlock();
-		/* no info found. */
-		return;
-	}
-	maxAge = dev_info->MaxAge;
-	HandleUnlock();
+    /* devices. */
+    for (handle = 1; handle <= 16; handle++) {
+        HandleLock();
+
+        if (GetHandleInfo(handle, &dev_info) != HND_DEVICE) {
+            HandleUnlock();
+            continue;
+        }
 
-	UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
-		   "MAX-AGE     =  %d\n", maxAge);
-	UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
-		   "MX     =  %d\n", event.Mx);
-	UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
-		   "DeviceType   =  %s\n", event.DeviceType);
-	UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
-		   "DeviceUuid   =  %s\n", event.UDN);
-	UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
-		   "ServiceType =  %s\n", event.ServiceType);
-	threadArg = (SsdpSearchReply *)malloc(sizeof(SsdpSearchReply));
-	if (threadArg == NULL)
-		return;
-	threadArg->handle = handle;
-	memcpy(&threadArg->dest_addr, dest_addr, sizeof(threadArg->dest_addr));
-	threadArg->event = event;
-	threadArg->MaxAge = maxAge;
-
-	TPJobInit(&job, advertiseAndReplyThread, threadArg);
-	TPJobSetFreeFunction(&job, (free_routine) free);
-
-	/* Subtract a percentage from the mx to allow for network and processing
-	 * delays (i.e. if search is for 30 seconds, respond
-	 * within 0 - 27 seconds). */
-	if (mx >= 2)
-		mx -= MAXVAL(1, mx / MX_FUDGE_FACTOR);
-	if (mx < 1)
-		mx = 1;
-	replyTime = rand() % mx;
-	TimerThreadSchedule(&gTimerThread, replyTime, REL_SEC, &job,
-			    SHORT_TERM, NULL);
+        maxAge = dev_info->MaxAge;
+        HandleUnlock();
+
+        UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
+               "MAX-AGE     =  %d\n", maxAge);
+        UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
+               "MX     =  %d\n", event.Mx);
+        UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
+               "DeviceType   =  %s\n", event.DeviceType);
+        UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
+               "DeviceUuid   =  %s\n", event.UDN);
+        UpnpPrintf(UPNP_PACKET, API, __FILE__, __LINE__,
+               "ServiceType =  %s\n", event.ServiceType);
+        threadArg = (SsdpSearchReply *)malloc(sizeof(SsdpSearchReply));
+        if (threadArg == NULL)
+            return;
+        threadArg->handle = handle;
+        memcpy(&threadArg->dest_addr, dest_addr, sizeof(threadArg->dest_addr));
+        threadArg->event = event;
+        threadArg->MaxAge = maxAge;
+
+        TPJobInit(&job, advertiseAndReplyThread, threadArg);
+        TPJobSetFreeFunction(&job, (free_routine) free);
+
+        /* Subtract a percentage from the mx to allow for network and processing
+         * delays (i.e. if search is for 30 seconds, respond
+         * within 0 - 27 seconds). */
+        if (mx >= 2)
+            mx -= MAXVAL(1, mx / MX_FUDGE_FACTOR);
+        if (mx < 1)
+            mx = 1;
+        replyTime = rand() % mx;
+        TimerThreadSchedule(&gTimerThread, replyTime, REL_SEC, &job,
+                    SHORT_TERM, NULL);
+    }
 }
 #endif
 
@@ -176,6 +175,8 @@
     int NumCopy,
     /*! [in] Ip address, to send the reply. */
 	struct sockaddr *DestAddr,
+    /*! [in] Ip address, to send from. */
+    const char *SrcAddr,
 	/*! [in] Number of packet to be sent. */
 	int NumPacket,
 	/*! [in] . */
@@ -183,9 +184,10 @@
 {
 	char errorBuffer[ERROR_BUFFER_LEN];
 	SOCKET ReplySock;
-	socklen_t socklen = sizeof(struct sockaddr_storage);
+    struct sockaddr_storage __ss;
+    struct sockaddr_in *ssdpAddr4 = (struct sockaddr_in *)&__ss;
+    socklen_t socklen = sizeof(struct sockaddr_storage);
 	int Index;
-	unsigned long replyAddr = inet_addr(gIF_IPV4);
 	/* a/c to UPNP Spec */
 	int ttl = 4;
 #ifdef INET_IPV6
@@ -206,10 +208,14 @@
 
 	switch (DestAddr->sa_family) {
 	case AF_INET:
-		inet_ntop(AF_INET, &((struct sockaddr_in *)DestAddr)->sin_addr,
+        ssdpAddr4->sin_family = (sa_family_t)AF_INET;
+        ssdpAddr4->sin_addr.s_addr = inet_addr(SrcAddr);
+        ssdpAddr4->sin_port = 0;
+        bind(ReplySock, (struct sockaddr *)ssdpAddr4, sizeof(*ssdpAddr4));
+        inet_ntop(AF_INET, &((struct sockaddr_in *)DestAddr)->sin_addr,
 			  buf_ntop, sizeof(buf_ntop));
 		setsockopt(ReplySock, IPPROTO_IP, IP_MULTICAST_IF,
-			   (char *)&replyAddr, sizeof(replyAddr));
+               (char *)&(ssdpAddr4->sin_addr.s_addr), sizeof(ssdpAddr4->sin_addr.s_addr));
 		setsockopt(ReplySock, IPPROTO_IP, IP_MULTICAST_TTL,
 			   (char *)&ttl, sizeof(int));
 		socklen = sizeof(struct sockaddr_in);
@@ -272,6 +278,38 @@
  *
  * \return 1 if an inet6 @ has been found.
  */
+static int extractIPv4address(char *url, char *address)
+{
+    int i = 0;
+    int j = 0;
+    int ret = 0;
+
+    while (((url[i] < '0') || (url[i] > '9')) && (url[i] != '\0')) {
+        i++;
+    }
+    if (url[i] == '\0') {
+        goto exit_function;
+    }
+
+    /* number has been found, we deal with an IPv4 address */
+    while ((((url[i] >= '0') && (url[i] <= '9')) || (url[i] == '.')) && (url[i] != '\0') && (j < (INET_ADDRSTRLEN - 1))) {
+        address[j] = url[i];
+        i++;
+        j++;
+    }
+
+    address[j] = '\0';
+    ret = 1;
+
+ exit_function:
+    return ret;
+}
+
+/*!
+ * \brief
+ *
+ * \return 1 if an inet6 @ has been found.
+ */
 static int extractIPv6address(char *url, char *address)
 {
 	int i = 0;
@@ -511,7 +549,8 @@
 	struct sockaddr_storage __ss;
 	struct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;
 	struct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;
-	/* char Mil_Nt[LINE_SIZE] */
+    char SrcAddr[INET6_ADDRSTRLEN];
+    /* char Mil_Nt[LINE_SIZE] */
 	char Mil_Usn[LINE_SIZE];
 	char *msgs[3];
 	int ret_code = UPNP_E_OUTOF_MEMORY;
@@ -567,17 +606,19 @@
 	if ((RootDev && msgs[0] == NULL) || msgs[1] == NULL || msgs[2] == NULL) {
 		goto error_handler;
 	}
-	/* send packets */
-	if (RootDev) {
-		/* send 3 msg types */
-		ret_code =
-            NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, 3, &msgs[0]);
-	} else {		/* sub-device */
-
-		/* send 2 msg types */
-		ret_code =
-            NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, 2, &msgs[1]);
-	}
+    /* send packets */
+    if (extractIPv6address(Location, SrcAddr) || extractIPv4address(Location, SrcAddr)) {
+        if (RootDev) {
+            /* send 3 msg types */
+            ret_code =
+                NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, SrcAddr, 3, &msgs[0]);
+        } else {		/* sub-device */
+
+            /* send 2 msg types */
+            ret_code =
+                NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, SrcAddr, 2, &msgs[1]);
+        }
+    }
 
 error_handler:
 	/* free msgs */
@@ -595,7 +636,8 @@
 	int ret_code = UPNP_E_OUTOF_MEMORY;
 	char *msgs[2];
 	int num_msgs;
-	char Mil_Usn[LINE_SIZE];
+    char SrcAddr[INET6_ADDRSTRLEN];
+    char Mil_Usn[LINE_SIZE];
 	int i;
 	int rc = 0;
 
@@ -641,7 +683,8 @@
 		}
 	}
 	/* send msgs */
-    ret_code = NewRequestHandler(NumCopy, DestAddr, num_msgs, msgs);
+    if (extractIPv6address(Location, SrcAddr) || extractIPv4address(Location, SrcAddr))
+        ret_code = NewRequestHandler(NumCopy, DestAddr, SrcAddr, num_msgs, msgs);
 
 error_handler:
 	for (i = 0; i < num_msgs; i++) {
@@ -656,7 +699,8 @@
         int NumCopy, char *Udn, char *Location, int Duration,
         int PowerState, int SleepPeriod, int RegistrationState)
 {
-	char *szReq[3], Mil_Nt[LINE_SIZE], Mil_Usn[LINE_SIZE];
+    char SrcAddr[INET6_ADDRSTRLEN];
+    char *szReq[3], Mil_Nt[LINE_SIZE], Mil_Usn[LINE_SIZE];
 	int RetVal = UPNP_E_OUTOF_MEMORY;
 	int rc = 0;
 
@@ -700,11 +744,13 @@
 		goto error_handler;
 	}
 	/* send replies */
-	if (RootDev) {
-        RetVal = NewRequestHandler(NumCopy, DestAddr, 3, szReq);
-	} else {
-        RetVal = NewRequestHandler(NumCopy, DestAddr, 2, &szReq[1]);
-	}
+    if (extractIPv6address(Location, SrcAddr) || extractIPv4address(Location, SrcAddr)) {
+        if (RootDev) {
+            RetVal = NewRequestHandler(NumCopy, DestAddr, SrcAddr, 3, szReq);
+        } else {
+            RetVal = NewRequestHandler(NumCopy, DestAddr, SrcAddr, 2, &szReq[1]);
+        }
+    }
 
 error_handler:
 	/* free */
@@ -719,7 +765,8 @@
 			 int Duration, int AddressFamily,
 			 int PowerState, int SleepPeriod, int RegistrationState)
 {
-	char Mil_Usn[LINE_SIZE];
+    char SrcAddr[INET6_ADDRSTRLEN];
+    char Mil_Usn[LINE_SIZE];
 	char *szReq[1];
 	int RetVal = UPNP_E_OUTOF_MEMORY;
 	struct sockaddr_storage __ss;
@@ -758,7 +805,8 @@
 	if (szReq[0] == NULL) {
 		goto error_handler;
 	}
-    RetVal = NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, 1, szReq);
+    if (extractIPv6address(Location, SrcAddr) || extractIPv4address(Location, SrcAddr))
+        RetVal = NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, SrcAddr, 1, szReq);
 
 error_handler:
 	free(szReq[0]);
@@ -770,7 +818,8 @@
 		 char *Location, int Duration, int PowerState, int SleepPeriod,
 		 int RegistrationState)
 {
-	char Mil_Usn[LINE_SIZE];
+    char SrcAddr[INET6_ADDRSTRLEN];
+    char Mil_Usn[LINE_SIZE];
 	char *szReq[1];
 	int RetVal = UPNP_E_OUTOF_MEMORY;
 	int rc = 0;
@@ -784,7 +833,8 @@
 			    PowerState, SleepPeriod, RegistrationState);
 	if (szReq[0] == NULL)
 		goto error_handler;
-    RetVal = NewRequestHandler(NumCopy, DestAddr, 1, szReq);
+    if (extractIPv6address(Location, SrcAddr) || extractIPv4address(Location, SrcAddr))
+        RetVal = NewRequestHandler(NumCopy, DestAddr, SrcAddr, 1, szReq);
 
 error_handler:
 	free(szReq[0]);
@@ -796,7 +846,8 @@
 		    int AddressFamily, int PowerState,
 		    int SleepPeriod, int RegistrationState)
 {
-	char Mil_Usn[LINE_SIZE];
+    char SrcAddr[INET6_ADDRSTRLEN];
+    char Mil_Usn[LINE_SIZE];
 	char *szReq[1];
 	struct sockaddr_storage __ss;
 	struct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;
@@ -835,7 +886,8 @@
 			    PowerState, SleepPeriod, RegistrationState);
 	if (szReq[0] == NULL)
 		goto error_handler;
-    RetVal = NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, 1, szReq);
+    if (extractIPv6address(Location, SrcAddr) || extractIPv4address(Location, SrcAddr))
+        RetVal = NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, SrcAddr, 1, szReq);
 
 error_handler:
 	free(szReq[0]);
@@ -851,7 +903,8 @@
 	struct sockaddr_in *DestAddr4 = (struct sockaddr_in *)&__ss;
 	struct sockaddr_in6 *DestAddr6 = (struct sockaddr_in6 *)&__ss;
 	char *msgs[3];
-	char Mil_Usn[LINE_SIZE];
+    char SrcAddr[INET6_ADDRSTRLEN];
+    char Mil_Usn[LINE_SIZE];
 	int ret_code = UPNP_E_OUTOF_MEMORY;
 	int rc = 0;
 
@@ -905,16 +958,18 @@
 		goto error_handler;
 	}
 	/* send packets */
-	if (RootDev) {
-		/* send 3 msg types */
-		ret_code =
-            NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, 3, &msgs[0]);
-	} else {
-		/* sub-device */
-		/* send 2 msg types */
-		ret_code =
-            NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, 2, &msgs[1]);
-	}
+    if (extractIPv6address(Location, SrcAddr) || extractIPv4address(Location, SrcAddr)) {
+        if (RootDev) {
+            /* send 3 msg types */
+            ret_code =
+                NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, SrcAddr, 3, &msgs[0]);
+        } else {
+            /* sub-device */
+            /* send 2 msg types */
+            ret_code =
+                NewRequestHandler(NumCopy, (struct sockaddr *)&__ss, SrcAddr, 2, &msgs[1]);
+        }
+    }
 
 error_handler:
 	/* free msgs */
--- upnp/src/ssdp/ssdp_server.c	2014-06-15 11:41:43.272990000 +0200
+++ upnp/src/ssdp/ssdp_server.c	2014-06-15 11:42:31.772992150 +0200
@@ -738,7 +738,7 @@
 	}
 	byteReceived = recvfrom(socket, requestBuf, BUFSIZE - (size_t)1, 0,
 				(struct sockaddr *)&__ss, &socklen);
-	if (byteReceived > 0) {
+    if ((byteReceived > 0) && IsBoundAddress(((struct sockaddr_in *)&__ss)->sin_addr.s_addr)) {
 		requestBuf[byteReceived] = '\0';
 		switch (__ss.ss_family) {
 		case AF_INET:
@@ -790,12 +790,11 @@
 {
 	char errorBuffer[ERROR_BUFFER_LEN];
 	int onOff;
-	u_char ttl = (u_char)4;
 	struct ip_mreq ssdpMcastAddr;
 	struct sockaddr_storage __ss;
 	struct sockaddr_in *ssdpAddr4 = (struct sockaddr_in *)&__ss;
+    int i;
 	int ret = 0;
-	struct in_addr addr;
 
 	*ssdpSock = socket(AF_INET, SOCK_DGRAM, 0);
 	if (*ssdpSock == INVALID_SOCKET) {
@@ -842,45 +841,24 @@
 		ret = UPNP_E_SOCKET_BIND;
 		goto error_handler;
 	}
-	memset((void *)&ssdpMcastAddr, 0, sizeof(struct ip_mreq));
-	ssdpMcastAddr.imr_interface.s_addr = inet_addr(gIF_IPV4);
-	ssdpMcastAddr.imr_multiaddr.s_addr = inet_addr(SSDP_IP);
-	ret = setsockopt(*ssdpSock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
-			 (char *)&ssdpMcastAddr, sizeof(struct ip_mreq));
-	if (ret == -1) {
-		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
-		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
-			   "Error in setsockopt() IP_ADD_MEMBERSHIP (join multicast group): %s\n",
-			   errorBuffer);
-		ret = UPNP_E_SOCKET_ERROR;
-		goto error_handler;
-	}
-	/* Set multicast interface. */
-	memset((void *)&addr, 0, sizeof(struct in_addr));
-	addr.s_addr = inet_addr(gIF_IPV4);
-	ret = setsockopt(*ssdpSock, IPPROTO_IP, IP_MULTICAST_IF,
-			 (char *)&addr, sizeof addr);
-	if (ret == -1) {
-		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
-		UpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,
-			   "Error in setsockopt() IP_MULTICAST_IF (set multicast interface): %s\n",
-			   errorBuffer);
-		/* This is probably not a critical error, so let's continue. */
-	}
-	/* result is not checked becuase it will fail in WinMe and Win9x. */
-	setsockopt(*ssdpSock, IPPROTO_IP,
-		IP_MULTICAST_TTL, &ttl, sizeof(ttl));
-	onOff = 1;
-	ret = setsockopt(*ssdpSock, SOL_SOCKET, SO_BROADCAST,
-			 (char *)&onOff, sizeof(onOff));
-	if (ret == -1) {
-		strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
-		UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
-			   "Error in setsockopt() SO_BROADCAST (set broadcast): %s\n",
-			   errorBuffer);
-		ret = UPNP_E_NETWORK_ERROR;
-		goto error_handler;
-	}
+    ret = UPNP_E_SOCKET_ERROR;
+    for (i = 0; gIFIP_IPV4[i] && (i < MAX_INTERFACES); i++) {
+        memset((void *)&ssdpMcastAddr, 0, sizeof(struct ip_mreq));
+        ssdpMcastAddr.imr_interface.s_addr = inet_addr(gIFIP_IPV4[i]);
+        ssdpMcastAddr.imr_multiaddr.s_addr = inet_addr(SSDP_IP);
+        ret = setsockopt(*ssdpSock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
+                 (char *)&ssdpMcastAddr, sizeof(struct ip_mreq));
+        if (ret == -1) {
+            strerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);
+            UpnpPrintf(UPNP_CRITICAL, SSDP, __FILE__, __LINE__,
+                   "Error in setsockopt() IP_ADD_MEMBERSHIP (join multicast group): %s\n",
+                   errorBuffer);
+        }
+        else
+            ret = UPNP_E_SUCCESS;
+    }
+    if (ret != UPNP_E_SUCCESS)
+        goto error_handler;
 	ret = UPNP_E_SUCCESS;
 
 error_handler:
@@ -917,7 +895,7 @@
 		return UPNP_E_OUTOF_SOCKET;
 	}
 	setsockopt(*ssdpReqSock, IPPROTO_IP, IP_MULTICAST_TTL,
-		   &ttl, sizeof(ttl));
+           (char *)&ttl, sizeof(ttl));
 	/* just do it, regardless if fails or not. */
 	sock_make_no_blocking(*ssdpReqSock);
 
@@ -1190,7 +1168,7 @@
 	out->ssdpReqSock4 = INVALID_SOCKET;
 	out->ssdpReqSock6 = INVALID_SOCKET;
 	/* Create the IPv4 socket for SSDP REQUESTS */
-	if (strlen(gIF_IPV4) > (size_t)0) {
+    if (gIFIP_IPV4[0]) {
 		retVal = create_ssdp_sock_reqv4(&out->ssdpReqSock4);
 		if (retVal != UPNP_E_SUCCESS)
 			return retVal;
@@ -1214,8 +1192,8 @@
 #endif /* IPv6 */
 #endif /* INCLUDE_CLIENT_APIS */
 	/* Create the IPv4 socket for SSDP */
-	if (strlen(gIF_IPV4) > (size_t)0) {
-		retVal = create_ssdp_sock_v4(&out->ssdpSock4);
+    if (gIFIP_IPV4[0]) {
+        retVal = create_ssdp_sock_v4(&out->ssdpSock4);
 		if (retVal != UPNP_E_SUCCESS) {
 #ifdef INCLUDE_CLIENT_APIS
 			shutdown(out->ssdpReqSock4, SD_BOTH);
